<media-controller
    id=controller
    keyboardforwardseekoffset=5
    keyboardbackwardseekoffset=5
    noautoseektolive
    style="aspect-ratio: {{info.aspect_ratio}}"

    {% if info.duration %}
        defaultduration={{info.duration}}
    {% endif %}

    {% if info.live_status == LiveStatus.is_live %}
        defaultstreamtype=live
    {% else %}
        defaultstreamtype=on-demand
    {% endif %}
>
    {% set ap = "autoplay" if autoplay else "" %}
    <hls-video id=hls slot=media src="{{info.manifest_url}}" type=hls {{ap}}>
        <track default kind=chapters src="{{info.chapters_url}}">
        <track label=thumbnails default kind=metadata
            src="{{info.storyboard_url}}"
        >
    </hls-video>

    <media-poster-image slot=poster src="{{info.best_thumbnail.fixed_url}}">
    </media-poster-image>

    <media-loading-indicator slot=centered-chrome noautohide>
    </media-loading-indicator>

    <media-play-button slot=centered-chrome></media-play-button>

    <media-playback-rate-menu
        rates="0.5 0.75 1 1.25 1.5 1.75 2 2.5 3"
        anchor=auto
        open-on-hover=speed-button
        hidden 
    >
        <div slot=header>Speed</div>
    </media-playback-rate-menu>

    <media-chrome-menu
        id=qualities
        anchor=quality-button
        open-on-hover=quality-button
        hidden
    >
        <div slot=header>Quality</div>
    </media-chrome-menu>

    <media-chrome-menu
        id=audio-tracks
        anchor=audio-button
        open-on-hover=audio-button
        hidden 
    >
        <div slot=header>Audio track</div>
    </media-chrome-menu>

    <media-captions-menu anchor=auto open-on-hover=subs-button hidden>
        <div slot=header>Subtitles</div>
    </media-captions-menu>

    <template id=menu-item-template>
        <media-chrome-menu-item
            type=radio role=menuitemradio part="menu-item radio"
        >
            <span></span>
        </media-chrome-menu-item>
    </template>

    <media-control-bar>
        <media-play-button></media-play-button>
        {% if info.live_status == LiveStatus.is_live %}
            <media-live-button></media-live-button>
        {% endif %}
        <media-mute-button></media-mute-button>
        <media-volume-range></media-volume-range>
        <media-time-range></media-time-range>
        <media-time-display showduration></media-time-display>
        <media-playback-rate-menu-button id=speed-button>
        </media-playback-rate-menu-button>
        <media-rendition-menu-button id=quality-button invoketarget=qualities>
            <span slot=icon>
                <div id=quality-indicator>Auto</div>
                <div id=auto-current-level></div>
            </span>
        </media-rendition-menu-button>
        <media-audio-track-menu-button
            id=audio-button invoketarget=audio-tracks class=no-choice
        >
        </media-audio-track-menu-button>
        <media-captions-menu-button id=subs-button>
        </media-captions-menu-button>
        <media-airplay-button></media-airplay-button>
        <media-cast-button></media-cast-button>
        <media-pip-button mediapipunavailable></media-pip-button>
        <media-fullscreen-button id=fullscreen-button>
        </media-fullscreen-button>
    </media-control-bar>
</media-controller>

<script type=module>
    import { Hls } from "/npm/hls-video-element@1.1.3/+esm"

    const controller = document.getElementById("controller")
    const media = document.getElementById("hls")
    const hls = document.getElementById("hls").api
    const qualities = document.getElementById("qualities")
    const qualityButton = document.getElementById("quality-button")
    const audioTracks = document.getElementById("audio-tracks")
    const audioButton = document.getElementById("audio-button")
    const fullscreenButton = document.getElementById("fullscreen-button")
    let initialSetQuality = true

    function levelFps(level) {
        return parseFloat(level.attrs["FRAME-RATE"] || "30")
    }

    function levelName(level) {
        function getBreakpoint(larger, smaller) {
            return smaller + ((larger - smaller) / 4)
        }
        const definition =
            level.height >= getBreakpoint(4320, 2160) ? level.height :
            level.height >= getBreakpoint(2160, 1440) ? 2160 :
            level.height >= getBreakpoint(1440, 1080) ? 1440 :
            level.height >= getBreakpoint(1080, 720) ? 1080 :
            level.height >= getBreakpoint(720, 480) ? 720 :
            level.height >= getBreakpoint(480, 360) ? 480 :
            level.height >= getBreakpoint(360, 240) ? 360 :
            level.height >= getBreakpoint(240, 144) ? 240 :
            144

        const fps = levelFps(level)
        return `${definition}p${fps > 23 && fps < 31 ? "" : Math.round(fps)}`
    }

    function createOption(name, value, checked=false) {
        const option = document.querySelector("#menu-item-template")
            .content.cloneNode(true).querySelector("media-chrome-menu-item")

        option.value = value
        option.ariaChecked = checked
        option.querySelector("span").textContent = name
        return option
    }

    function createQualityOption(name, minBitrate, maxLevel) {
        const option = createOption(name, name)
        option.setAttribute("min-bitrate", minBitrate)
        option.setAttribute("max-level", maxLevel)
        return option
    }

    function intAttr(element, attr) {
        return parseInt(element.attributes[attr].value, 10)
    }

    function haveClass(el, cls, haveIt) {
        haveIt ? el.classList.add(cls) : el.classList.remove(cls)
    }

    function onLevelsUpdate(event, data) {
        const levels = data.levels
        console.log("levels:", levels)
        let opts = Object.fromEntries(levels.map(lv => [levelName(lv), lv]))

        opts = Object.values(opts).reverse().map(lv => createQualityOption(
            levelName(lv),
            levels.reduce((a, b) =>
                a.height === lv.height &&
                levelFps(a) === levelFps(lv) &&
                a.bitrate < b.bitrate ? a : b
            ).bitrate,
            levels.indexOf(levels.filter(other =>
                other.height === lv.height && levelFps(other) === levelFps(lv)
            ).slice(-1)[0]),
        ))
        const auto = createQualityOption("Auto", 0, -1,)
        opts.push(auto)
        const header = qualities.querySelector("[slot=header]")
        while (header.nextSibling) header.nextSibling.remove()
        for (const opt of opts) qualities.appendChild(opt)
        haveClass(qualityButton, "no-choice", opts.length < 2)
        opts.forEach(o => console.log(o.value, o.ariaChecked, o.checked))

        const saved = getCookie("quality")
        const choice = saved === null ? auto : (
            opts.find(e => e.value === saved) ||
            opts.find(e => e.value.startsWith(saved.split("p")[0])) ||
            opts[0]
        )
        opts.forEach(e => e.checked = e === choice)
        observeChecked(qualities, setQuality)
    }

    function onLevelSwitch(event, data) {
        const opt = document.querySelector("#qualities [aria-checked=true]")
        if (opt.value !== "Auto") return
        const name = levelName(hls.levels[hls.currentLevel])
        document.querySelector("#auto-current-level").textContent = name
    }

    function onSubsUpdate(event, data) {
        const want = getCookie("subtitles")
        if (! want) return
        const baseLang = want.lang.split("-")[0]
        const track = hls.allSubtitleTracks.find(t => t.name === want.name) ||
            hls.allSubtitleTracks.find(t => t.lang === want.lang) ||
            hls.allSubtitleTracks.find(t => t.lang.split("-")[0] === baseLang)

        hls.setSubtitleOption({name: track.name})
    }

    function onSubsSwitch(event, data) {
        const sub = hls.subtitleTracks[data.id]
        setCookie("subtitles", sub ? {name: sub.name, lang: sub.lang} : null)
    }

    function onAudioTracksUpdate() {
        const header = audioTracks.querySelector("[slot=header]")
        const opts = hls.audioTracks.map(at => createOption(
            at.name, at.id, hls.audioTrack === at.id,
        ))
        while (header.nextSibling) header.nextSibling.remove()
        for (const opt of opts) audioTracks.appendChild(opt)
        haveClass(audioButton, "no-choice", opts.length < 2)
        observeChecked(audioTracks, setAudioTrack)
    }

    function setQuality() {
        const opt = document.querySelector("#qualities [aria-checked=true]")
        if (! opt) return
        hls.config.minAutoBitrate = intAttr(opt, "min-bitrate") - 1
        hls.autoLevelCapping = intAttr(opt, "max-level")
        hls.streamController.nextLevelSwitch()
        const button = document.querySelector("#quality-button")
        haveClass(button, "auto", opt.value === "Auto")
        document.querySelector("#quality-indicator").textContent = opt.value

        if (initialSetQuality) {
            initialSetQuality = false
        } else {
            setCookie("quality", opt.value)
        }
        //console.log(hls.config.minAutoBitrate, hls.autoLevelCapping)
    }

    function setAudioTrack() {
        const opt = document.querySelector("#audio-tracks [aria-checked=true]")
        if (! opt) return
        hls.audioTrack = opt.value
        audioButton.mediaAudioTrackEnabled = opt.value
    }

    function observeChecked(menu, onChange) {
        let refireCooldownTimerId
        const observer = new MutationObserver(mutations => {
            mutations.forEach(mut => {
                if (! mut.target.ariaChecked) return
                if (mut.oldValue == mut.target.ariaChecked) return
                clearTimeout(refireCooldownTimerId)
                refireCooldownTimerId = setTimeout(onChange, 100)
            })
        })
        observer.observe(menu, {
            attributes: true,
            childList: true,
            subtree: true,
            attributeFilter: ["aria-checked"],
            attributeOldValue: true,
        })
    }

    let fastForwardStartTimerId = null
    let fastForwarding = false
    let pausedBeforeFastForward = false
    let speedBeforeFastForward = 1

    function startFastForwardSoon() {
        fastForwardStartTimerId = setTimeout(() => {
            pausedBeforeFastForward = media.paused
            speedBeforeFastForward = media.playbackRate
            media.playbackRate *= 2
            media.play()
            fastForwarding = true
        }, 500)
    }

    function stopFastForward() {
        clearTimeout(fastForwardStartTimerId)
        if (! fastForwarding) return
        media.playbackRate = speedBeforeFastForward
        pausedBeforeFastForward ? media.pause() : media.play()
        fastForwarding = false
    }

    hls.on(Hls.Events.MANIFEST_LOADED, onLevelsUpdate)
    hls.on(Hls.Events.LEVELS_UPDATED, onLevelsUpdate)
    hls.on(Hls.Events.AUDIO_TRACKS_UPDATED, onAudioTracksUpdate)
    hls.on(Hls.Events.LEVEL_SWITCHED, onLevelSwitch)
    hls.on(Hls.Events.SUBTITLE_TRACK_SWITCH, onSubsSwitch)
    hls.on(Hls.Events.SUBTITLE_TRACKS_UPDATED, onSubsUpdate)
    hls.on(Hls.Events.ERROR, console.error)

    const maxBandwidthRemembered = 2048 * 8192  // 2MiB/s in bits
    hls.bandwidthEstimate = getCookie("bandwidth", 50 * 8192)
    hls.on(Hls.Events.FRAG_LOADED, (event, data) => {
        const max = maxBandwidthRemembered
        setCookie("bandwidth", Math.min(max, hls.bandwidthEstimate), 60 * 120)
    })

    media.addEventListener("loadedmetadata", () => {
        const params = new URL(window.location.href).searchParams
        let start = params.get("start") || params.get("t")
        if (start) seekVideo(media, start)
    })

    media.volume = getCookie("volume", 1.0)
    media.muted = getCookie("muted", false)
    media.addEventListener("volumechange", () => {
        setCookie("volume", media.volume)
        setCookie("muted", media.muted)
    })

    media.playbackRate = getCookie("speed", 1.0)
    media.addEventListener("ratechange", () => {
        if (! fastForwarding) setCookie("speed", media.playbackRate)
    })

    media.addEventListener("mousedown", event => {
        if (event.button === 0) startFastForwardSoon()
    })
    media.addEventListener("mouseleave", () => {
        stopFastForward()
    })
    media.addEventListener("click", event => {
        if (event.button !== 0) return
        if (fastForwarding) event.stopPropagation()
        stopFastForward()
    })

    media.addEventListener("dblclick", () => {
        fullscreenButton.click()
    })

    media.addEventListener("ended", () => {
        // user may be currently dragging the time slider around
        if (controller.hasAttribute("mediapreviewtime")) return

        function nextVideo() {
            const url = new URL(document.querySelector(
                "#playlist .entry.highlight + .entry [href^='/watch']"
            ).href)
            url.searchParams.set("autoplay", "1")
            window.location.href = url.href
        }
        nextVideo()  // may fail is playlist hasn't finished loading yet
        setInterval(nextVideo, 1000)
    })

    document.querySelectorAll("[open-on-hover]").forEach(menu => {
        const buttonId = menu.getAttribute("open-on-hover")
        const button = document.getElementById(buttonId)

        function onLeave() {
            if (! menu.hasAttribute("hover-opened")) return
            if (button.matches(":hover") || menu.matches(":hover")) return
            menu.removeAttribute("hover-opened")
            menu.hidden = true
        }

        menu.addEventListener("mouseleave", onLeave)
        button.addEventListener("mouseleave", onLeave)
        button.addEventListener("mouseenter", () => {
            if (! menu.hidden) return
            menu.setAttribute("hover-opened", "")
            menu.hidden = false
        })
        button.addEventListener("click", () => { 
            if (! menu.hasAttribute("hover-opened")) return
            menu.removeAttribute("hover-opened")
            menu.hidden = false
        })
        menu.addEventListener("click", () => { 
            if (menu.hasAttribute("hover-opened")) menu.hidden = true 
        })
    })

    processHmsTimeLinks(media)

    // HACK: workaround for Vieb's follow mode algorithm landing on 
    //  uninteractive shadow root elements like <svg> and not being able to
    //  associate them to the clickable parent elements
    document.querySelectorAll(
        "media-controller > media-play-button, " +
        "media-control-bar > " +
        ":not(:is(media-time-range, media-volume-range)):not(:has([slot]))"
    ).forEach(control => { 
        const el = document.createElement("button")
        el.style.position = "absolute"
        el.style.width = "100%"
        el.style.height = "100%"
        el.style.cursor = "pointer"
        el.style.opacity = 0
        control.style.position = "relative"
        control.shadowRoot.appendChild(el)
    })
</script>
