<media-controller
    {# autohide #}
    keyboardforwardseekoffset=5
    keyboardbackwardseekoffset=5
    noautoseektolive
    style="aspect-ratio: {{video.aspect_ratio}}"

    {% if video.duration %}
        defaultduration={{video.duration}}
    {% endif %}

    {% if video.live_status == LiveStatus.is_live %}
        defaultstreamtype=live
    {% else %}
        defaultstreamtype=on-demand
    {% endif %}
>
    <hls-video id=hls slot=media src="{{video.manifest_url}}" type=hls>
        <track default kind=chapters src="{{video.chapters_url}}">
        <track label=thumbnails default kind=metadata
            src="{{video.storyboard_url}}"
        >
    </hls-video>

    <media-poster-image slot=poster src="{{video.best_thumbnail.fixed_url}}">
    </media-poster-image>

    <media-loading-indicator slot=centered-chrome noautohide>
    </media-loading-indicator>

    <media-play-button slot=centered-chrome></media-play-button>

    <media-playback-rate-menu
        rates="0.5 0.75 1 1.25 1.5 1.75 2 2.5 3" hidden anchor=auto>
        <div slot=header>Speed</div>
    </media-playback-rate-menu>
    <media-chrome-menu hidden anchor=quality-button id=qualities>
        <div slot=header>Quality</div>
    </media-chrome-menu>
    <media-chrome-menu hidden anchor=audio-button id=audio-tracks>
        <div slot=header>Audio track</div>
    </media-chrome-menu>
    <media-captions-menu hidden anchor=auto>
        <div slot=header>Subtitles</div>
    </media-captions-menu>

    <template id=menu-item-template>
        <media-chrome-menu-item
            type=radio role=menuitemradio part="menu-item radio"
        >
            <span></span>
        </media-chrome-menu-item>
    </template>

    <media-control-bar>
        <media-play-button></media-play-button>
        {% if video.live_status == LiveStatus.is_live %}
            <media-live-button></media-live-button>
        {% endif %}
        <media-mute-button></media-mute-button>
        <media-volume-range></media-volume-range>
        <media-time-range></media-time-range>
        <media-time-display showduration></media-time-display>
        <media-playback-rate-menu-button></media-playback-rate-menu-button>
        <media-rendition-menu-button id=quality-button invoketarget=qualities>
            <span slot=icon id=quality-indicator>Auto</span>
        </media-rendition-menu-button>
        <media-audio-track-menu-button
            id=audio-button invoketarget=audio-tracks class=no-choice
        >
        </media-audio-track-menu-button>
        <media-captions-menu-button></media-captions-menu-button>
        <media-airplay-button></media-airplay-button>
        <media-cast-button></media-cast-button>
        <media-pip-button mediapipunavailable></media-pip-button>
        <media-fullscreen-button></media-fullscreen-button>
    </media-control-bar>
</media-controller>

{# Putting these attrs on the video itself causes duplicate triggering #}
<div
    hx-get="{{get_related}}"
    hx-trigger=load
    hx-select=#explore-column
    hx-target=#explore-column
    hx-swap="ignoreTitle:true"
></div>

<script type=module>
    import { Hls } from "/npm/hls-video-element@1.1.3/+esm"

    const hls = document.getElementById("hls").api
    const qualities = document.getElementById("qualities")
    const qualityButton = document.getElementById("quality-button")
    const audioTracks = document.getElementById("audio-tracks")
    const audioButton = document.getElementById("audio-button")

    function levelFps(level) {
        return parseFloat(level.attrs["FRAME-RATE"] || "30")
    }

    function levelName(level) {
        const height = level.height
        const fps = levelFps(level)
        return `${height}p${fps > 23 && fps < 31 ? "" : Math.round(fps)}`
    }

    function createOption(name, value, checked=false) {
        const option = document.querySelector("#menu-item-template")
            .content.cloneNode(true).querySelector("media-chrome-menu-item")

        option.value = value
        option.ariaChecked = checked
        option.querySelector("span").textContent = name
        return option
    }

    function createQualityOption(name, minBitrate, maxLevel, checked=false) {
        const option = createOption(name, name, checked)
        option.setAttribute("min-bitrate", minBitrate)
        option.setAttribute("max-level", maxLevel)
        return option
    }

    function intAttr(element, attr) {
        return parseInt(element.attributes[attr].value, 10)
    }

    function haveClass(el, cls, haveIt) {
        haveIt ? el.classList.add(cls) : el.classList.remove(cls)
    }

    function onLevelsUpdate(event, data) {
        const levels = data.levels
        console.log("levels:", levels)
        let opts = Object.fromEntries(levels.map(lv => [levelName(lv), lv]))

        opts = Object.values(opts).reverse().map(lv => createQualityOption(
            levelName(lv),
            levels.reduce((a, b) =>
                a.height === lv.height &&
                levelFps(a) === levelFps(lv) &&
                a.bitrate < b.bitrate ? a : b
            ).bitrate,
            levels.indexOf(levels.filter(other =>
                other.height === lv.height && levelFps(other) === levelFps(lv)
            ).slice(-1)[0]),
        ))
        opts.push(createQualityOption("Auto", 0, -1, true))
        const header = qualities.querySelector("[slot=header]")
        while (header.nextSibling) header.nextSibling.remove()
        for (const opt of opts) qualities.appendChild(opt)
        haveClass(qualityButton, "no-choice", opts.length < 2)
    }

    function onAudioTracksUpdate() {
        const header = audioTracks.querySelector("[slot=header]")
        const opts = hls.audioTracks.map(at => createOption(
            at.name, at.id, hls.audioTrack === at.id,
        ))
        while (header.nextSibling) header.nextSibling.remove()
        for (const opt of opts) audioTracks.appendChild(opt)
        haveClass(audioButton, "no-choice", opts.length < 2)
    }

    function setQuality() {
        const opt = document.querySelector("#qualities [aria-checked=true]")
        if (! opt) return
        hls.config.minAutoBitrate = intAttr(opt, "min-bitrate") - 1
        hls.autoLevelCapping = intAttr(opt, "max-level")
        hls.streamController.nextLevelSwitch()
        document.querySelector("#quality-indicator").textContent = opt.value
        //console.log(hls.config.minAutoBitrate, hls.autoLevelCapping)
    }

    function setAudioTrack() {
        const opt = document.querySelector("#audio-tracks [aria-checked=true]")
        if (! opt) return
        hls.audioTrack = opt.value
        audioButton.mediaAudioTrackEnabled = opt.value
    }

    function observeChecked(menu, onChange) {
        let refireCooldownTimerId
        const observer = new MutationObserver(mutations => {
            mutations.forEach(mut => {
                if (! mut.target.ariaChecked) return
                if (mut.oldValue == mut.target.ariaChecked) return
                clearTimeout(refireCooldownTimerId)
                refireCooldownTimerId = setTimeout(onChange, 100)
            })
        })
        observer.observe(menu, {
            attributes: true,
            childList: true,
            subtree: true,
            attributeFilter: ["aria-checked"],
            attributeOldValue: true,
        })
    }

    hls.on(Hls.Events.MANIFEST_LOADED, onLevelsUpdate)
    hls.on(Hls.Events.LEVELS_UPDATED, onLevelsUpdate)
    hls.on(Hls.Events.AUDIO_TRACKS_UPDATED, onAudioTracksUpdate)
    observeChecked(qualities, setQuality)
    observeChecked(audioTracks, setAudioTrack)

    // HACK: workaround for Vieb's follow mode algorithm landing on 
    //  uninteractive shadow root elements like <svg> and not being able to
    //  associate them to the clickable parent elements
    document.querySelectorAll(
        "media-controller > media-play-button, " +
        "media-control-bar > " +
        ":not(:is(media-time-range, media-volume-range)):not(:has([slot]))"
    ).forEach(control => { 
        const el = document.createElement("button")
        el.style.position = "absolute"
        el.style.width = "100%"
        el.style.height = "100%"
        el.style.cursor = "pointer"
        el.style.opacity = 0
        control.style.position = "relative"
        control.shadowRoot.appendChild(el)
    })
</script>
